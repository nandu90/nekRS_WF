@kernel void RANSktauComputeHex3D(const dlong N,
                                  const dlong offset,
                                  const dlong mid,
                                  const dfloat rho,
                                  const dfloat mue,
                                  @ restrict const dfloat *K,
                                  @ restrict const dfloat *TAU,
                                  @ restrict const dfloat *STMAG2,
                                  @ restrict const dfloat *OIOJSK,
                                  @ restrict const dfloat *XK,
                                  @ restrict const dfloat *XT,
                                  @ restrict const dfloat *XTQ,
                                  @ restrict const dfloat *YWD,
                                  @ restrict dfloat *SRCDIAG,
                                  @ restrict dfloat *SRC)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner))
    if(n < N){
      const dfloat xk = XK[n];
      const dfloat xt = XT[n];
      const dfloat xtq = XTQ[n];

      const dfloat stMag2 = STMAG2[n];
      const dfloat OiOjSk = OIOJSK[n];

      const dfloat kk = K[n];
      const dfloat tau = TAU[n];

      dfloat itau = 0;
      if (tau > 0)
        itau = 1 / (tau + p_tiny);

      dfloat mu_t = 0.0;
      dfloat Y_k;
      dfloat Y_w, S_w0, G_wp, S_tau, S_taup;

      if(mid == 0){
        mu_t = rho * p_alpinf_str * kk * tau;

        dfloat sigd = p_sigd_min;
        dfloat f_beta_str = 1.0;
        if (xk > 0) {
          const dfloat xk3 = xk * xk * tau * tau;
          sigd = p_sigd_max;
          f_beta_str = (1.0 + p_fb_c1st * xk3) / (1.0 + p_fb_c2st * xk3);
        }

        // compute source term for k
        Y_k = rho * p_betainf_str * f_beta_str * itau;

        // compute source term for tau
        const dfloat x_w = fabs(OiOjSk) * (tau * tau * tau * p_ibetainf_str3);
        const dfloat f_b = (p_pope) ? (1.0 + p_fb_c1 * x_w) / (1.0 + p_fb_c2 * x_w) : 1.0;
        Y_w = -rho * p_beta0 * f_b;
        S_w0 = -rho * sigd *xk;
        G_wp = rho * p_alp_inf * tau * 2*stMag2;

        S_tau = fmin(8.0 * mue * xtq, 4.0 * p_beta0 / 3.0);
        S_taup = 8.0 * rho * p_alpinf_str * kk * xtq * p_sigma_tau;	  
      }
      else if(mid == 1){
        dfloat f1 = 1.0;
        const dfloat yw = YWD[n];

        SSTBlendingFunc(rho, mue, kk, tau, stMag2, xk, yw, f1, mu_t);

        Y_k = rho * p_betainf_str * itau;

        const dfloat f11 = 1.0 - f1;
        const dfloat beta = f1 * p_beta0_SST + f11 * p_beta2;
        const dfloat gamma = f1 * p_alp_inf_SST + f11 * p_gamma2;
        const dfloat sigom = f1 * p_sigma_tau + f11 * p_sigom2;

        Y_w = -rho * beta;
        S_w0 = -2.0 * rho * p_sigom2 * f11 * xk;
        G_wp = rho * gamma * tau * 2 * stMag2;

        S_tau = fmin(8.0 * mue * xtq, 8.0 * beta / 3.0);
        S_taup = 8.0 * rho * kk * xtq * sigom;
      }

      const dfloat kSrc = fmin(mu_t * 2*stMag2, 10.0 * Y_k * kk);
      const dfloat kDiag = Y_k;

      dfloat tauSrc = 0.0;
      dfloat tauDiag = 0.0;
      if(tau < p_tiny){
        tauSrc = -Y_w - S_tau;
        tauDiag = G_wp - S_w0 + S_taup;
      }
      else{
        tauSrc = -Y_w;
        tauDiag = G_wp - S_w0 + S_taup + S_tau * itau;
      }

      SRC[n + 0 * offset] = kSrc;
      SRC[n + 1 * offset] = tauSrc;
      SRCDIAG[n + 0 * offset] = kDiag;
      SRCDIAG[n + 1 * offset] = tauDiag;
    }
}
