C
C  USER SPECIFIED ROUTINES: 
C
C     - boundary conditions 
C     - initial conditions  
C     - variable properties 
C     - forcing function for fluid (f)
C     - forcing function for passive scalar (q)
C     - general purpose routine for checking errors etc.        
C
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e

      e = gllel(ieg)

      ux   = 0.00  
      uy   = 0.01 
      uz   = 0.0

      if (ifield.eq.2) then
         temp = 1.0 - xm1(ix,iy,iz,e)
      elseif (ifield.eq.3) then
         temp = 0.01
      elseif (ifield.eq.4) then
         temp = 0.1
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      real BETAM
      parameter(BETAM=2.2)


      ntot = lx1*ly1*lz1*nelt

      xmin = abs(glmin(xm1,ntot))
      ymin = abs(glmin(ym1,ntot))
      do i=1,ntot
        sgnx = sign(1.,xm1(i,1,1,1))
        sgny = sign(1.,ym1(i,1,1,1))
        xx = abs(xm1(i,1,1,1))
        yy = abs(ym1(i,1,1,1))
        xm1(i,1,1,1) = sgnx*(tanh(BETAM*2*xx)/tanh(BETAM))/2.0 + xmin
        ym1(i,1,1,1) = sgny*(tanh(BETAM*2*yy)/tanh(BETAM))/2.0 + ymin
      enddo

      do iel=1,nelt
         ! cbc(5,iel,1) = 'P  '
         ! cbc(6,iel,1) = 'P  '
      do ifc=1,2*ndim
         cbc(ifc,iel,2)  = cbc(ifc,iel,1)
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,2) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,3) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,4) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryIDt(ifc,iel) = 1
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
            
      common /inarrs/ 
     $     t1in(lx1,ly1,lz1,lelv)
      real t1in

      common /NRSSCPTR/ nrs_scptr(1)
      integer*8 nrs_scptr

      call getWallTemp
      nrs_scptr(1) = loc(t1in(1,1,1,1))

      return
      end
c-----------------------------------------------------------------------
      subroutine getWallTemp
      include 'SIZE'
      include 'TOTAL'

      do ie=1,nelt
         do ifc=1,2*ndim
            ieg = lglel(ie)
            if(cbc(ifc,ie,1).eq.'W  ')then
               CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,lx1,ly1,lz1,IFACE)
               do IZ=KZ1,KZ2
                  do IY=KY1,KY2
                     do IX=KX1,KX2
                        CALL fillbc  (IX,IY,IZ,ifc,ieg)
                     enddo
                  enddo
               enddo
            endif
         enddo
      enddo
      
      return
      end
c-----------------------------------------------------------------------
      subroutine fillbc(ix,iy,iz,iside,eg) ! set up boundary conditions
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
c
      common /inarrs/ 
     $     t1in(lx1,ly1,lz1,lelv)
      real t1in

      integer ix,iy,iz,iside,e,eg

      integer icalld
      save icalld
      data icalld /0/

      real T_bottom, T_top
      real xx,yy

      e = gllel(eg)

      if(icalld.eq.0)then
        call getTempProf
        icalld = 1
      endif

      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)

      if(xx.lt.1e-8 .or. abs(xx-1.).lt.1e-8)then !hot/cold walls
        temp = 1.- xx
      else !bottom/top walls
        call initprof(xx,T_top,T_bottom)
        if(yy.lt.0.5)temp = T_bottom
        if(yy.gt.0.5)temp = T_top
      endif

      t1in(ix,iy,iz,e) = temp

      return
      end
c-----------------------------------------------------------------------
      subroutine getTempProf

      include 'SPLINE'

      real YY(npts),ZZ(npts)

      if (nid.eq.0) then
         write(*,'(A,I4)')      'npts  = ', npts
         write(*,'(A,1pE10.2)') 'ymin = ', ymin
         write(*,'(A,1pE10.2)') 'ymax = ', ymax
         write(*,'(A,1pE10.2)') 'ymin_turb = ', ymin_turb
         write(*,'(A,1pE10.2)') 'ymax_turb = ', ymax_turb
      endif

C  Read in the 1-D profile computed by turbChan2D
C        velocity       in fU
C        kinetic energy in fK
C        omega          in fO

      open(unit=100,file='exp_hwall.dat',status='old')
      read(100, *)     ! skip the header
      do i=1,npts
        read(100,*)  YY(i), fU(i), fK(i)
c        write(*,*)  YY(i), fU(i), fK(i)
      enddo
      close(100)

C  compute spline coefficients for U
      do i=1,npts
        ZZ(i)  = fU(i)
        SYY(i) = YY(i)
      enddo
      call spline (npts, YY, ZZ, sbU, scU, sdU)

C  compute spline coefficients for T
      do i=1,npts
        ZZ(i) = fK(i)
      enddo
      call spline (npts, YY, ZZ, sbK, scK, sdK)

      return
      end

c-----------------------------------------------------------------------
      subroutine spline (n, x, y, b, c, d)

c  the coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
c  for a cubic interpolating spline
c
c    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
c
c    for  x(i) .le. x .le. x(i+1)
c
c  input.. 
c
c    n = the number of data points or knots (n.ge.2)
c    x = the abscissas of the knots in strictly increasing order
c    y = the ordinates of the knots
c
c  output..
c
c    b, c, d  = arrays of spline coefficients as defined above.
c
c  using  p  to denote differentiation,
c
c    y(i) = s(x(i))
c    b(i) = sp(x(i))
c    c(i) = spp(x(i))/2
c    d(i) = sppp(x(i))/6  (derivative from the right)
c
c  the accompanying function subprogram  seval  can be used
c  to evaluate the spline.

      integer n
      real x(n), y(n), b(n), c(n), d(n)

      integer nm1, ib, i
      real t

C      do i = 1, n
C        if (nid.eq.0) write(41,'(1p2E13.5)') x(i), y(i)
C      enddo
C      if (nid.eq.0) write(41,'(A)') '&'

      nm1 = n-1
      if ( n .lt. 2 ) return
      if ( n .lt. 3 ) go to 50

c  set up tridiagonal system
c  b = diagonal, d = offdiagonal, c = right hand side.

      d(1) = x(2) - x(1)
      c(2) = (y(2) - y(1))/d(1)
      do 10 i = 2, nm1
         d(i) = x(i+1) - x(i)
         b(i) = 2.*(d(i-1) + d(i))
         c(i+1) = (y(i+1) - y(i))/d(i)
         c(i) = c(i+1) - c(i)
   10 continue

c  end conditions.  third derivatives at  x(1)  and  x(n)
c  obtained from divided differences

      b(1) = -d(1)
      b(n) = -d(n-1)
      c(1) = 0.0
      c(n) = 0.0
      if ( n .eq. 3 ) go to 15
      c(1) = c(3)/(x(4)-x(2)) - c(2)/(x(3)-x(1))
      c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
      c(1) = c(1)*d(1)**2/(x(4)-x(1))
      c(n) = -c(n)*d(n-1)**2/(x(n)-x(n-3))

c  forward elimination

   15 do 20 i = 2, n
         t = d(i-1)/b(i-1)
         b(i) = b(i) - t*d(i-1)
         c(i) = c(i) - t*c(i-1)
   20 continue

c  back substitution

      c(n) = c(n)/b(n)
      do 30 ib = 1, nm1
         i = n-ib
         c(i) = (c(i) - d(i)*c(i+1))/b(i)
   30 continue

c  c(i) is now the sigma(i) of the text
c
c  compute polynomial coefficients

      b(n) = (y(n) - y(nm1))/d(nm1) + d(nm1)*(c(nm1) + 2.*c(n))
      do 40 i = 1, nm1
         b(i) = (y(i+1) - y(i))/d(i) - d(i)*(c(i+1) + 2.*c(i))
         d(i) = (c(i+1) - c(i))/d(i)
         c(i) = 3.*c(i)
   40 continue
      c(n) = 3.0*c(n)
      d(n) = d(n-1)
      return

   50 b(1) = (y(2)-y(1))/(x(2)-x(1))
      c(1) = 0.0
      d(1) = 0.0
      b(2) = b(1)
      c(2) = 0.0
      d(2) = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine initprof(y,Uin,Kin)
c
c Compute temperature + species using cubic splines
c   f(y) = s(i) + sb(i)*(y-SYY(i)) + sc(i)*(y-SYY(i))**2 + sd(i)*(y-SYY(i))**3

      include 'SPLINE'

      real y, Uin, Kin, Oin

      ii = 0
      do i=1,npts-1
        if (y.ge.SYY(i) .and. y.lt.SYY(i+1)) ii=i
      enddo
      if(abs(y-SYY(npts)).lt.1e-7) ii=npts

      if (ii.le.0) then
        write(*,*) 'Error in init_mean: ii= ', ii,'>npts=', npts, y
        call exitt
      endif

      Uin=fU(ii) + sbU(ii)*(y-SYY(ii))
     *     +scU(ii)*(y-SYY(ii))**2+sdU(ii)*(y-SYY(ii))**3

      if (y.ge.SYY(npts)) Uin=fU(npts)

      Kin=fK(ii) + sbK(ii)*(y-SYY(ii))
     *     +scK(ii)*(y-SYY(ii))**2+sdK(ii)*(y-SYY(ii))**3

      if (y.ge.SYY(npts)) Kin=fK(npts)
      return
      end
