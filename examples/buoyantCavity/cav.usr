C
C  USER SPECIFIED ROUTINES: 
C
C     - boundary conditions 
C     - initial conditions  
C     - variable properties 
C     - forcing function for fluid (f)
C     - forcing function for passive scalar (q)
C     - general purpose routine for checking errors etc.        
C
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e

      e = gllel(ieg)

      ux   = 0.00  
      uy   = 0.01 
      uz   = 0.0

      if (ifield.eq.2) then
         temp = 1.0 - xm1(ix,iy,iz,e)
      elseif (ifield.eq.3) then
         temp = 0.01
      elseif (ifield.eq.4) then
         temp = 0.1
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      
      common /postpro/ tavgs(lx1,ly1,lz1,lelt,6),
     $                 sij(lx1,ly1,lz1,lelt,6),
     $                 gradT(lx1,ly1,lz1,lelt,3)
      real tavgs,sij,gradT

      real ptA(3),ptB(3)

      nxyz = lx1*ly1*lz1
      ntot = nxyz*lelt

      call copy(vx,tavgs(1,1,1,1,1),ntot)
      call copy(vy,tavgs(1,1,1,1,2),ntot)
      call copy(vz,tavgs(1,1,1,1,3),ntot)
      call copy(t(1,1,1,1,1),tavgs(1,1,1,1,4),ntot)
      call copy(t(1,1,1,1,2),tavgs(1,1,1,1,5),ntot)
      call copy(t(1,1,1,1,3),tavgs(1,1,1,1,6),ntot)

      ptA(1) = 0.0
      ptA(2) = 0.5
      ptA(3) = 0.0
      ptB(1) = 1.0
      ptB(2) = 0.5
      ptB(3) = 0.0

      call lineplot(ptA,ptB,10001)
      call analysis

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      real BETAM
      parameter(BETAM=2.2)


      ntot = lx1*ly1*lz1*nelt

      xmin = abs(glmin(xm1,ntot))
      ymin = abs(glmin(ym1,ntot))
      do i=1,ntot
        sgnx = sign(1.,xm1(i,1,1,1))
        sgny = sign(1.,ym1(i,1,1,1))
        xx = abs(xm1(i,1,1,1))
        yy = abs(ym1(i,1,1,1))
        xm1(i,1,1,1) = sgnx*(tanh(BETAM*2*xx)/tanh(BETAM))/2.0 + xmin
        ym1(i,1,1,1) = sgny*(tanh(BETAM*2*yy)/tanh(BETAM))/2.0 + ymin
      enddo

      do iel=1,nelt
         ! cbc(5,iel,1) = 'P  '
         ! cbc(6,iel,1) = 'P  '
      do ifc=1,2*ndim
         cbc(ifc,iel,2)  = cbc(ifc,iel,1)
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,2) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,3) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,4) = 't  ' 
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'W  ') boundaryIDt(ifc,iel) = 1
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
            
      common /inarrs/ 
     $     t1in(lx1,ly1,lz1,lelv)
      real t1in

      common /postpro/ tavgs(lx1,ly1,lz1,lelt,6),
     $                 sij(lx1,ly1,lz1,lelt,6),
     $                 gradT(lx1,ly1,lz1,lelt,3)
      real tavgs,sij,gradT

      call getWallTemp
      call nekrs_registerPtr('tin',t1in)

      call nekrs_registerPtr('tavgs',tavgs)
      call nekrs_registerPtr('sij',sij)
      call nekrs_registerPtr('gradT',gradT)
      

      return
      end
c-----------------------------------------------------------------------
      subroutine getWallTemp
      include 'SIZE'
      include 'TOTAL'

      do ie=1,nelt
         do ifc=1,2*ndim
            ieg = lglel(ie)
            if(cbc(ifc,ie,1).eq.'W  ')then
               CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,lx1,ly1,lz1,IFACE)
               do IZ=KZ1,KZ2
                  do IY=KY1,KY2
                     do IX=KX1,KX2
                        CALL fillbc  (IX,IY,IZ,ifc,ieg)
                     enddo
                  enddo
               enddo
            endif
         enddo
      enddo
      
      return
      end
c-----------------------------------------------------------------------
      subroutine fillbc(ix,iy,iz,iside,eg) ! set up boundary conditions
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
c
      common /inarrs/ 
     $     t1in(lx1,ly1,lz1,lelv)
      real t1in

      integer ix,iy,iz,iside,e,eg

      integer icalld
      save icalld
      data icalld /0/

      real T_bottom, T_top
      real xx,yy

      e = gllel(eg)

      if(icalld.eq.0)then
        call getTempProf
        icalld = 1
      endif

      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)

      if(xx.lt.1e-8 .or. abs(xx-1.).lt.1e-8)then !hot/cold walls
        temp = 1.- xx
      else !bottom/top walls
        call initprof(xx,T_top,T_bottom)
        if(yy.lt.0.5)temp = T_bottom
        if(yy.gt.0.5)temp = T_top
      endif

      t1in(ix,iy,iz,e) = temp

      return
      end
c-----------------------------------------------------------------------
      subroutine getTempProf

      include 'SPLINE'

      real YY(npts),ZZ(npts)

      if (nid.eq.0) then
         write(*,'(A,I4)')      'npts  = ', npts
         write(*,'(A,1pE10.2)') 'ymin = ', ymin
         write(*,'(A,1pE10.2)') 'ymax = ', ymax
         write(*,'(A,1pE10.2)') 'ymin_turb = ', ymin_turb
         write(*,'(A,1pE10.2)') 'ymax_turb = ', ymax_turb
      endif

C  Read in the 1-D profile computed by turbChan2D
C        velocity       in fU
C        kinetic energy in fK
C        omega          in fO

      open(unit=100,file='exp_hwall.dat',status='old')
      read(100, *)     ! skip the header
      do i=1,npts
        read(100,*)  YY(i), fU(i), fK(i)
c        write(*,*)  YY(i), fU(i), fK(i)
      enddo
      close(100)

C  compute spline coefficients for U
      do i=1,npts
        ZZ(i)  = fU(i)
        SYY(i) = YY(i)
      enddo
      call spline (npts, YY, ZZ, sbU, scU, sdU)

C  compute spline coefficients for T
      do i=1,npts
        ZZ(i) = fK(i)
      enddo
      call spline (npts, YY, ZZ, sbK, scK, sdK)

      return
      end

c-----------------------------------------------------------------------
      subroutine spline (n, x, y, b, c, d)

c  the coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
c  for a cubic interpolating spline
c
c    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
c
c    for  x(i) .le. x .le. x(i+1)
c
c  input.. 
c
c    n = the number of data points or knots (n.ge.2)
c    x = the abscissas of the knots in strictly increasing order
c    y = the ordinates of the knots
c
c  output..
c
c    b, c, d  = arrays of spline coefficients as defined above.
c
c  using  p  to denote differentiation,
c
c    y(i) = s(x(i))
c    b(i) = sp(x(i))
c    c(i) = spp(x(i))/2
c    d(i) = sppp(x(i))/6  (derivative from the right)
c
c  the accompanying function subprogram  seval  can be used
c  to evaluate the spline.

      integer n
      real x(n), y(n), b(n), c(n), d(n)

      integer nm1, ib, i
      real t

C      do i = 1, n
C        if (nid.eq.0) write(41,'(1p2E13.5)') x(i), y(i)
C      enddo
C      if (nid.eq.0) write(41,'(A)') '&'

      nm1 = n-1
      if ( n .lt. 2 ) return
      if ( n .lt. 3 ) go to 50

c  set up tridiagonal system
c  b = diagonal, d = offdiagonal, c = right hand side.

      d(1) = x(2) - x(1)
      c(2) = (y(2) - y(1))/d(1)
      do 10 i = 2, nm1
         d(i) = x(i+1) - x(i)
         b(i) = 2.*(d(i-1) + d(i))
         c(i+1) = (y(i+1) - y(i))/d(i)
         c(i) = c(i+1) - c(i)
   10 continue

c  end conditions.  third derivatives at  x(1)  and  x(n)
c  obtained from divided differences

      b(1) = -d(1)
      b(n) = -d(n-1)
      c(1) = 0.0
      c(n) = 0.0
      if ( n .eq. 3 ) go to 15
      c(1) = c(3)/(x(4)-x(2)) - c(2)/(x(3)-x(1))
      c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
      c(1) = c(1)*d(1)**2/(x(4)-x(1))
      c(n) = -c(n)*d(n-1)**2/(x(n)-x(n-3))

c  forward elimination

   15 do 20 i = 2, n
         t = d(i-1)/b(i-1)
         b(i) = b(i) - t*d(i-1)
         c(i) = c(i) - t*c(i-1)
   20 continue

c  back substitution

      c(n) = c(n)/b(n)
      do 30 ib = 1, nm1
         i = n-ib
         c(i) = (c(i) - d(i)*c(i+1))/b(i)
   30 continue

c  c(i) is now the sigma(i) of the text
c
c  compute polynomial coefficients

      b(n) = (y(n) - y(nm1))/d(nm1) + d(nm1)*(c(nm1) + 2.*c(n))
      do 40 i = 1, nm1
         b(i) = (y(i+1) - y(i))/d(i) - d(i)*(c(i+1) + 2.*c(i))
         d(i) = (c(i+1) - c(i))/d(i)
         c(i) = 3.*c(i)
   40 continue
      c(n) = 3.0*c(n)
      d(n) = d(n-1)
      return

   50 b(1) = (y(2)-y(1))/(x(2)-x(1))
      c(1) = 0.0
      d(1) = 0.0
      b(2) = b(1)
      c(2) = 0.0
      d(2) = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine initprof(y,Uin,Kin)
c
c Compute temperature + species using cubic splines
c   f(y) = s(i) + sb(i)*(y-SYY(i)) + sc(i)*(y-SYY(i))**2 + sd(i)*(y-SYY(i))**3

      include 'SPLINE'

      real y, Uin, Kin, Oin

      ii = 0
      do i=1,npts-1
        if (y.ge.SYY(i) .and. y.lt.SYY(i+1)) ii=i
      enddo
      if(abs(y-SYY(npts)).lt.1e-7) ii=npts

      if (ii.le.0) then
        write(*,*) 'Error in init_mean: ii= ', ii,'>npts=', npts, y
        call exitt
      endif

      Uin=fU(ii) + sbU(ii)*(y-SYY(ii))
     *     +scU(ii)*(y-SYY(ii))**2+sdU(ii)*(y-SYY(ii))**3

      if (y.ge.SYY(npts)) Uin=fU(npts)

      Kin=fK(ii) + sbK(ii)*(y-SYY(ii))
     *     +scK(ii)*(y-SYY(ii))**2+sdK(ii)*(y-SYY(ii))**3

      if (y.ge.SYY(npts)) Kin=fK(npts)
      return
      end
c-----------------------------------------------------------------------
      subroutine analysis
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real ptA(3), ptB(3)
      real Nu(lx1,ly1,lz1,lelv)
      real uv(lx1,ly1,lz1,lelv)
      real uT(lx1,ly1,lz1,lelv)
      real vT(lx1,ly1,lz1,lelv)

      integer ie,ifc,ix,iy,iz,i
      integer kx1,kx2,ky1,ky2,kz1,kz2

      real usn(3)
      real Nuss,tx,ty,tz
      integer nxyz,ntot

      real mu_t
      real rans_mut,Prt_buo

      character*3 bcw
      common /postpro/ tavgs(lx1,ly1,lz1,lelt,6),
     $                 sij(lx1,ly1,lz1,lelt,6),
     $                 gradT(lx1,ly1,lz1,lelt,3)
      real tavgs,sij,gradT

      nxyz=lx1*ly1*lz1
      ntot=nxyz*nelt

      Prt_buo = 0.85

      do ie=1,nelv
        do i=1,lx1*ly1*lz1
          mu_t = t(i,1,1,ie,2)*t(i,1,1,ie,3)
          uT(i,1,1,ie) = (mu_t/Prt_buo)*gradT(i,1,1,ie,1)
          vT(i,1,1,ie) = (mu_t/Prt_buo)*gradT(i,1,1,ie,2)
          uv(i,1,1,ie) = -mu_t*2.0*sij(i,1,1,ie,2)
        enddo
      enddo

      do ie=1,nelv
        do ifc = 1,2*ndim
          bcw = cbc(ifc,ie,1)
          if(bcw .eq. 'W  ')then
            CALL FACIND (KX1,KX2,KY1,KY2,KZ1,KZ2,lx1,ly1,lz1,ifc)
            do iz = kz1,kz2
              do iy = ky1,ky2
                do ix = kx1,kx2
                  call getSnormal(usn,ix,iy,iz,ifc,ie)
                  tx = gradT(ix,iy,iz,ie,1)
                  ty = gradT(ix,iy,iz,ie,2)
                  tz = gradT(ix,iy,iz,ie,3)
                  Nuss = tx*usn(1)+ty*usn(2)
                  if(if3d) Nuss = Nuss+tz*usn(3)
                  Nu(ix,iy,iz,ie) = Nuss
                enddo
              enddo
            enddo
          endif
        enddo
      enddo

      !store Nu in pressure field
      call copy(pr,Nu,ntot)

      !Hot wall
      ptA(1) = 0.0
      ptA(2) = 0.0
      ptA(3) = 0.0
      ptB(1) = 0.0
      ptB(2) = 1.0
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      !cold wall
      ptA(1) = 1.0
      ptA(2) = 0.0
      ptA(3) = 0.0
      ptB(1) = 1.0
      ptB(2) = 1.0
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      !Bottom wall
      ptA(1) = 0.0
      ptA(2) = 0.0
      ptA(3) = 0.0
      ptB(1) = 1.0
      ptB(2) = 0.0
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      !Top wall
      ptA(1) = 0.0
      ptA(2) = 1.0
      ptA(3) = 0.0
      ptB(1) = 1.0
      ptB(2) = 1.0
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      !Mid-width
      ptA(1) = 0.5
      ptA(2) = 0.0
      ptA(3) = 0.0
      ptB(1) = 0.5
      ptB(2) = 1.0
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      !Mid-height - uv,uT,vT
      call copy(vx,uv,ntot)
      call copy(t(1,1,1,1,1),uT,ntot)
      call copy(t(1,1,1,1,2),vT,ntot)
      ptA(1) = 0.0
      ptA(2) = 0.5
      ptA(3) = 0.0
      ptB(1) = 1.0
      ptB(2) = 0.5
      ptB(3) = 0.0
      call lineplot(ptA,ptB,10001)

      return
      end
c-----------------------------------------------------------------------
      subroutine lineplot(pt1,pt2,lpts)
      implicit none
      include 'SIZE'
      include 'TOTAL'

      real pt1(ldim),pt2(ldim)
      integer npts,lpts,iplot,ls

      character*141 fname
      character*10 ftail
      character*14 afmt
      character*10 rfmt
      integer intp_h,i,j,nt,nfld
      save intp_h
      logical ifset,ifdo
      real dx,pts(lhis,3)
      real fwrk(lx1*ly1*lz1*lelt,ldim+1+ldimt)
      real fpts(lhis*(ldim+1+ldimt))
      real uout(lhis),vout(lhis),wout(lhis)
      real prout(lhis),tout(lhis,ldimt)
      character*4 outname(ldim+1+ldimt)

      real rwrk(lhis,ldim+1)
      integer iwrk(lhis,3)
      save rwrk,iwrk

      save ifdo,ifset
      data ifdo /.true./
      data ifset /.true./

      save iplot
      data iplot /1/


      if(.not.ifdo) return

      nt=lx1*ly1*lz1*nelt

      npts=max(lpts,2)
      if(npts.gt.lhis) then
        if(nio.eq.0) write(*,*)
     &       "Error in lineplot, recompile with lhis in SIZE >= ",npts
        ifdo=.false.
        return
      endif
     
      call rzero(pts,npts*ndim)
      do j=1,ndim 
        pts(1,j)=pt1(j)
        dx=(pt2(j)-pt1(j))/(real(npts-1))
        do i=2,npts
          pts(i,j)=pts(i-1,j)+dx
        enddo
      enddo

      if(ifset)then
        ifset=.false.
        call interp_setup(intp_h,0.0,0,nelt)
      endif

      nfld=0
      if(ifvo) then
        write(outname(1),'(a4)')"VELX"
        write(outname(2),'(a4)')"VELY"
        call copy(fwrk(1,1),vx,nt)
        call copy(fwrk(1,2),vy,nt)
        nfld=2
      endif
      if(if3d.and.ifvo)then
        nfld=nfld+1
        write(outname(nfld),'(a4)')"VELZ"
        call copy(fwrk(1,nfld),vz,nt)
      endif
      if(ifpo) then
        nfld=nfld+1
        write(outname(nfld),'(a4)')"PRES"
        call copy(fwrk(1,nfld),pr,nt)
      endif
      if(ifheat) then
        if(ifto) then
          nfld=nfld+1
          write(outname(nfld),'(a4)')"TEMP"
          call copy(fwrk(1,nfld),t,nt)
        endif
        do i=1,ldimt-1
            nfld=nfld+1
            write(outname(nfld),'(a2,i2)')"PS",i
            call copy(fwrk(1,nfld),t(1,1,1,1,i+1),nt)
        enddo
      endif

      if(nfld.gt.0) then

        if(nid.ne.0) npts=0

        call blank(fname,141)
        call blank(ftail,9)
        if(iplot.lt.10) then
          write(ftail,'(a,i1,a)') ".0000",iplot,".dat"
        elseif(iplot.lt.100) then
          write(ftail,'(a,i2,a)') ".000",iplot,".dat"
        elseif(iplot.lt.1000) then
          write(ftail,'(a,i3,a)') ".00",iplot,".dat"
        elseif(iplot.lt.10000) then
          write(ftail,'(a,i4,a)') ".0",iplot,".dat"
        else
          write(ftail,'(a,i5,a)') ".",iplot,".dat"
        endif
        fname=trim(session)//ftail

        if(nio.eq.0) then
          write(*,*)'   Writing line plot data to file ',fname
          if(if3d)then
            write(*,'(7x,3es15.6)')pt1(1),pt1(2),pt1(ldim)
            write(*,'(7x,3es15.6)')pt2(1),pt2(2),pt2(ldim)
          else
            write(*,'(7x,2es15.6)')pt1(1),pt1(2)
            write(*,'(7x,2es15.6)')pt2(1),pt2(2)
          endif
          write(*,*)
        endif
   
        call interp_nfld(fpts,fwrk,nfld,pts(1,1),pts(1,2),pts(1,3),npts
     &                                    ,iwrk,rwrk,lhis,.true.,intp_h)

        call blank(afmt,14)
        call blank(rfmt,10)
        if(if3d) then
          write(afmt,'(a1,i2,a11)')"(",nfld+3,"a16,es16.8)"
          write(rfmt,'(a1,i2,a7)')"(",nfld+3,"es16.8)"
        else
          write(afmt,'(a1,i2,a11)')"(",nfld+2,"a16,es16.8)"
          write(rfmt,'(a1,i2,a7)')"(",nfld+2,"es16.8)"
        endif
  
        if(nio.eq.0) then
          open(unit=10,file=fname,status='unknown',form='formatted')
          if(if3d) then
            write(10,afmt)"X","Y","Z",(outname(i),i=1,nfld),time
          else
            write(10,afmt)"X","Y",(outname(i),i=1,nfld),time
          endif
          do i=1,npts
            if(if3d) then
              write(10,rfmt)pts(i,1),pts(i,2),pts(i,3)
     &                               ,(fpts(i+j),j=0,(npts*nfld-1),npts)
            else
              write(10,rfmt)pts(i,1),pts(i,2)
     &                               ,(fpts(i+j),j=0,(npts*nfld-1),npts)
            endif
          enddo
        endif
  
        close(10)
  
        iplot=iplot+1
      endif

      return
      end
c-----------------------------------------------------------------------
