C
C  USER SPECIFIED ROUTINES: 
C
C     - boundary conditions 
C     - initial conditions  
C     - variable properties 
C     - forcing function for fluid (f)
C     - forcing function for passive scalar (q)
C     - general purpose routine for checking errors etc.        
C
c-----------------------------------------------------------------------
      include "/home/nsaini/Nek5000/core/experimental/lineplot.f"
      include "/home/nsaini/Nek5000/core/experimental/limits.f"
      include "/home/nsaini/Nek5000/core/experimental/utilities.f"
c---------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      real kmax

      Re    = 1/param(2)
      kmax  = 3.9201E-03
      omax  = 0.5

      ux   = 1.0  
      uy   = 0.0 
      uz   = 0.0

      yd = 1 + y
      tau = 0.0
      if(yd.ne.0) then
         omeg = omax + 6./Re/0.075/yd**2
         tau = 1/omeg
      endif

      if (ifield.eq.2) then
         temp = 1.0
      elseif (ifield.eq.3) then
         temp = kmax
      elseif (ifield.eq.4) then
         temp = tau
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'RANS_KOMG'

      real w1,w2,w3,w4,w5
      common /SCRNS/
     &     w1(lx1*ly1*lz1*lelv)
     &     ,w2(lx1*ly1*lz1*lelv)
     &     ,w3(lx1*ly1*lz1*lelv)
     &     ,w4(lx1*ly1*lz1*lelv)
     &     ,w5(lx1*ly1*lz1*lelv)

      common /NRSSCPTR/ nrs_scptr(10)
      integer*8 nrs_scptr

      common /gradywd/ ywdx(lx1,ly1,lz1,lelv),ywdy(lx1,ly1,lz1,lelv)
     $     ,ywdz(lx1,ly1,lz1,lelv),ywdc(lx1,ly1,lz1,lelv)
      
      real ptA(3),ptB(3)

      if(istep.eq.0)then
         call distf2(ywd,1,'shl','W  ',w1,w2,w3,w4,w5)
c     call get_gradywd  !calculate gradients in nekRS
         nrs_scptr(1) = loc(ywd(1,1,1,1))

         ptA(1) = 0.0
         ptA(2) = -1.0
         ptA(3) = 0.0
         ptB(1) = 0.0
         ptB(2) = 0.0
         ptB(3) = 0.0

        call lineplot(ptA,ptB,10001)
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2()  ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      parameter(BETAM = 1.8)

      call rescale_x(xm1, 0.0,8.0)
      call rescale_x(ym1,-1.0,0.0)
      call rescale_x(zm1, 0.0,1.0)

      ntot = nx1*ny1*nz1*nelt

      do i=1,ntot
         ym1(i,1,1,1) = tanh(BETAM*ym1(i,1,1,1))/tanh(BETAM)
      enddo

      do iel=1,nelt
         cbc(5,iel,1) = 'P  '
         cbc(6,iel,1) = 'P  '
      do ifc=1,2*ndim
         cbc(ifc,iel,2)  = cbc(ifc,iel,1)
         if (cbc(ifc,iel,1) .eq. 'shl') cbc(ifc,iel,2) = 'f  ' 
         if (cbc(ifc,iel,1) .eq. 'SYM') cbc(ifc,iel,2) = 'I  ' 
         if (cbc(ifc,iel,1) .eq. 'shl') boundaryID(ifc,iel) = 1
         if (cbc(ifc,iel,1) .eq. 'SYM') boundaryID(ifc,iel) = 2
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrsetvert(glo_num,nel,nx,ny,nz) ! to modify glo_num
      integer*8 glo_num(1)

      ! kludge for periodic bc in z
      nxy  = nx*ny
      nxyz = nx*ny*nz
      do iel = 1,nel
         ioff = nxyz*(iel-1)
         do ixy = 1,nxy
            glo_num(ioff + nxy*(nz-1) + ixy) = glo_num(ioff + ixy)
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine get_gradywd
      include 'SIZE'
      include 'TOTAL'
      include 'RANS_KOMG'

      common /gradywd/ ywdx(lx1,ly1,lz1,lelv),ywdy(lx1,ly1,lz1,lelv)
     $                ,ywdz(lx1,ly1,lz1,lelv),ywdc(lx1,ly1,lz1,lelv)

      ntot = lx1*ly1*lz1*lelv

      call gradm1 (ywdx,ywdy,ywdz,   ywd)
      call opcolv (ywdx,ywdy,ywdz,   bm1)
      call opdssum(ywdx,ywdy,ywdz)
      call opcolv (ywdx,ywdy,ywdz,binvm1)
      call copy   (ywdc,ywd ,ntot)

      return
      end
c-----------------------------------------------------------------------            
      subroutine distf2(d,ifld,b1,b2,dmin,emin,xn,yn,zn)

c     Generate a distance function to boundary with bc "b1" or "b2".
c     This approach does not yet work with periodic boundary conditions.

c     INPUT:  ifld - field type for which distance function is to be found.
c             ifld = 1 for velocity
c             ifld = 2 for temperature, etc.

c     OUTPUT: d = distance to nearest boundary with boundary condition "b"

c     Work arrays:  dmin,emin,xn,yn,zn

      include 'SIZE'
      include 'GEOM'       ! Coordinates
      include 'INPUT'      ! cbc()
      include 'TSTEP'      ! nelfld
      include 'PARALLEL'   ! gather-scatter handle for field "ifld"

      real d(lx1,ly1,lz1,lelt)
      character*3 b1, b2

      real dmin(lx1,ly1,lz1,lelt),emin(lx1,ly1,lz1,lelt)
      real xn(lx1,ly1,lz1,lelt),yn(lx1,ly1,lz1,lelt)
      real zn(lx1,ly1,lz1,lelt)


      integer e,eg,f

      nel = nelfld(ifld)
      n = lx1*ly1*lz1*nel

      call domain_size(xmin,xmax,ymin,ymax,zmin,zmax)

      xmn = min(xmin,ymin)
      xmx = max(xmax,ymax)
      if (if3d) xmn = min(xmn ,zmin)
      if (if3d) xmx = max(xmx ,zmax)

      big = 10*(xmx-xmn)
      call cfill (d,big,n)

      call opcopy(xn,yn,zn,xm1,ym1,zm1)

      nface = 2*ldim
      do e=1,nel     ! Set d=0 on walls
      do f=1,nface
         if (cbc(f,e,1).eq.b1 .or. cbc(f,e,1).eq.b2)
     $              call facev(d,e,f,0.,lx1,ly1,lz1)
      enddo
      enddo

      nxyz = lx1*ly1*lz1

      do ipass=1,10000
         dmax    = 0
         nchange = 0
         do e=1,nel
            do k=1,lz1
            do j=1,ly1
            do i=1,lx1
              i0=max(  1,i-1)
              j0=max(  1,j-1)
              k0=max(  1,k-1)
              i1=min(lx1,i+1)
              j1=min(ly1,j+1)
              k1=min(lz1,k+1)
              do kk=k0,k1
              do jj=j0,j1
              do ii=i0,i1

               dself  = d(i,j,k,e)
               dneigh = d(ii,jj,kk,e)
               if (dneigh.lt.dself) then  ! check neighbor's nearest point
                  d2 = (xm1(i,j,k,e)-xn(ii,jj,kk,e))**2
     $               + (ym1(i,j,k,e)-yn(ii,jj,kk,e))**2
                  if (if3d) d2 = d2 + (zm1(i,j,k,e)-zn(ii,jj,kk,e))**2
                  if (d2.gt.0) d2 = sqrt(d2)
                  if (d2.lt.dself) then
                    nchange = nchange+1
                    d (i,j,k,e) = d2
                    xn(i,j,k,e) = xn(ii,jj,kk,e)
                    yn(i,j,k,e) = yn(ii,jj,kk,e)
                    zn(i,j,k,e) = zn(ii,jj,kk,e)
                    dmax = max(dmax,d(i,j,k,e))
                  endif
               endif
              enddo
              enddo
              enddo
            enddo
            enddo
            enddo
            re = lglel(e)
            call cfill(emin(1,1,1,e),re,nxyz)
            call copy (dmin(1,1,1,e),d(1,1,1,e),nxyz)
         enddo
         nchange = iglsum(nchange,1)
         call fgslib_gs_op(gsh_fld(ifld),dmin,1,3,0) ! min over all elements
         nchange2=0
         do e=1,nel
         do i=1,nxyz
          if (dmin(i,1,1,e).ne.d(i,1,1,e)) then
             nchange2 = nchange2+1
             emin(i,1,1,e) = 0  ! Flag
          endif
         enddo
         enddo
         call copy(d,dmin,n)                !   Ensure updated distance
         nchange2 = iglsum(nchange2,1)
         nchange  = nchange + nchange2
         call fgslib_gs_op(gsh_fld(ifld),emin,1,4,0) ! max over all elements
         do e=1,nel    ! Propagate nearest wall points
         do i=1,nxyz
          eg = emin(i,1,1,e)
          if (eg.ne.lglel(e)) then
             xn(i,1,1,e) = 0
             yn(i,1,1,e) = 0
             zn(i,1,1,e) = 0
          endif
         enddo
         enddo
         call fgslib_gs_op(gsh_fld(ifld),xn,1,1,0) !   Sum over all elements to
         call fgslib_gs_op(gsh_fld(ifld),yn,1,1,0) !   convey nearest point
         call fgslib_gs_op(gsh_fld(ifld),zn,1,1,0) !   to shared neighbor.
         dmax = glmax(dmax,1)
         if (nio.eq.0) write(6,1) ipass,nchange,dmax
 1           format(i9,i12,1pe12.4,' max wall distance 2')
         if (nchange.eq.0) goto 1000
      enddo
 1000  continue
c     wgt = 0.3
c     call filter_d2(d,lx1,lz1,wgt,.true.)
      return
      end
c-----------------------------------------------------------------------                  
